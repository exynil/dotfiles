#!/bin/bash

# Функция генерации TOTP кода
generate_totp() {
    local secret_base32="$1"
    local digits="$2"
    local interval="$3"

    # Декодируем base32 в hex
    local secret_hex=$(echo -n "$secret_base32" | tr 'a-z' 'A-Z' | base32 -d 2>/dev/null | xxd -p | tr -d '\n')

    if [[ -z "$secret_hex" ]]; then
        return 1
    fi

    # Вычисляем счетчик времени
    local time_now=$(date +%s)
    local counter=$(( time_now / interval ))

    # Преобразуем счетчик в 8-байтный hex (big-endian)
    local counter_hex=$(printf "%016x" "$counter")

    # Вычисляем HMAC-SHA1
    local hash=$(echo -n "$counter_hex" | xxd -r -p | openssl dgst -sha1 -mac HMAC -macopt hexkey:"$secret_hex" | awk '{print $2}')

    # Динамическое усечение
    local offset=$(( 0x${hash: -1} ))
    local part=${hash:$((offset * 2)):8}

    local code=$(( 0x$part & 0x7fffffff ))
    local mod=$(( 10 ** digits ))
    local otp=$(( code % mod ))

    printf "%0*d" "$digits" "$otp"
}

# Функция вычисления оставшегося времени
calculate_remain() {
    local interval="$1"
    local time_now=$(date +%s)
    local remain=$(( interval - (time_now % interval) ))
    echo "$remain"
}

# Получаем путь к файлу secrets из переменной окружения
if [[ -z "$TOTP_SECRETS_FILE" ]]; then
    echo "Ошибка: переменная окружения TOTP_SECRETS_FILE не установлена" >&2
    exit 1
fi
SECRETS_FILE="$TOTP_SECRETS_FILE"

# Выводим список всех кодов
if [[ ! -f "$SECRETS_FILE" ]]; then
    echo "Ошибка: файл $SECRETS_FILE не найден" >&2
    exit 1
fi

# Первый проход: находим максимальную длину названия
max_name_length=0
while IFS= read -r line || [[ -n "$line" ]]; do
    # Пропускаем пустые строки и комментарии
    [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

    read -r name secret digits interval <<< "$line"
    name_len=${#name}
    if [[ $name_len -gt $max_name_length ]]; then
        max_name_length=$name_len
    fi
done < "$SECRETS_FILE"

# Второй проход: выводим с выравниванием
while IFS= read -r line || [[ -n "$line" ]]; do
    # Пропускаем пустые строки и комментарии
    [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

    read -r name secret digits interval <<< "$line"

    CODE=$(generate_totp "$secret" "$digits" "$interval")
    REMAIN=$(calculate_remain "$interval")

    printf "%-*s  %s  (%ds)\n" "$max_name_length" "$name" "$CODE" "$REMAIN"
done < "$SECRETS_FILE"